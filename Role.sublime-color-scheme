// Experimental scheme with fewer roles and colors. Work in progress.
{
  "variables": {
    "bg": "hsl(200, 5%, 10%)",
    "fg": "white",
    "comment_fg": "hsl(60, 10%, 60%)",
    "action_fg": "hsl(120, 80%, 80%)",
    "declaration_fg": "hsl(220, 75%, 90%)",
    "modifier_fg": "hsl(240, 70%, 80%)",
    "raw_bg": "color(var(fg) alpha(0.04))",
    "illegal_fg": "hsl(0, 100%, 60%)",
    "invisible": "hsl(0, 0%, 20%)",
    "selection": "hsl(0, 0%, 30%)",
  },
  "globals": {
    "background": "var(bg)",
    "caret": "var(fg)",
    "foreground": "var(fg)",
    "invisibles": "var(invisible)",
    "line_highlight": "var(selection)",
    "selection": "var(selection)",
    "selection_border": "var(bg)",
  },
  "rules": [
    {
      "scope": "comment",
      "foreground": "var(comment_fg)",
      "background": "var(raw_bg)",
    },
    {
      "scope": "punctuation.section, punctuation.definition.interpolation, punctuation.definition.group, variable.language.blank, variable.language.anonymous",
      "foreground": "var(comment_fg)",
    },
    {
      "scope": "entity.name - entity.name.tag, variable.parameter, variable.declaration, variable.other.constant.declaration, meta.declaration variable.other,  meta.binding variable.other, variable.other.member.declaration",
      "foreground": "var(declaration_fg)",
      "font_style": "italic",
    },
    {
      "scope": "keyword, punctuation, variable.function, storage.type.keyword, entity.name.tag, string constant.other.placeholder",
      "foreground": "var(action_fg)",
    },
    {
      "scope": "storage, entity.other.inherited-class, punctuation.definition",
      "foreground": "var(modifier_fg)",
    },
    {
      "scope": "string",
      "background": "var(raw_bg)",
    },
    {
      "scope": "invalid.illegal, invalid.deprecated",
      "foreground": "var(illegal_fg)",
    },
    {
      "scope": "constant.character.escape",
      "font_style": "bold",
    },

    /* Markup */

    {
      "scope": "markup.raw",
      "background": "var(raw_bg)",
    },
    {
      "scope": "meta.link.inline.description",
      "background": "var(raw_bg)",
    },
    {
      "scope": "markup.underline.link",
      "background": "var(raw_bg)",
    },
    {
      "scope": "markup.italic - punctuation.definition.italic",
      "font_style": "italic",
    },
    {
      "scope": "markup.bold - punctuation.definition.bold",
      "font_style": "bold",
    },
    {
      // Semantically, this could be considered a "label" in the vein similar to
      // a struct field in a struct literal. If we ever allocate a color for
      // that, this rule should use it.
      "scope": "text constant.other.language-name",
      "background": "var(raw_bg)",
    },

    /* Overrides and special cases */

    // Avoid forward fill. Must be one simple selector.
    {
      "scope": "keyword.declaration",
      "foreground": "var(action_fg)",
    },
    {
      "scope": "source.rust support.function, source.rust support.macro",
      "foreground": "var(action_fg)",
    },
    {
      "scope": "source.scss entity.other.attribute-name - meta.at-rule, source.scss entity.name.tag - meta.at-rule, source.scss entity.other.animation-name",
      "foreground": "var(declaration_fg)",
      "font_style": "italic",
    },
    {
      "scope": "meta.import.js variable.other",
      "foreground": "var(declaration_fg)",
      "font_style": "italic",
    },
    {
      "scope": "meta.import.js constant.other",
      "foreground": "var(action_fg)",
    },
    {
      "scope": "storage.type.class.js",
      "foreground": "var(action_fg)",
    },
    {
      "scope": "source.shell support.function",
      "foreground": "var(action_fg)",
    },
    {
      "scope": "source.haskell support.type, source.haskell support.class, source.haskell support.constant",
      "foreground": "var(modifier_fg)",
    },
  ],
}
